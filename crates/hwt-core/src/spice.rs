//! SPICE Netlist Export Module.
//!
//! Generates SPICE netlists from schematic data for circuit simulation.
//! Supports standard SPICE format compatible with ngspice, LTspice, etc.

use std::collections::HashMap;
use std::fmt::Write;

use crate::schematic::{SchematicSheet, PlacedSymbol};

/// SPICE netlist generator.
pub struct SpiceNetlistGenerator {
    /// Title for the netlist
    title: String,
    /// Component models to include
    models: Vec<SpiceModel>,
    /// Subcircuit definitions
    subcircuits: Vec<SpiceSubcircuit>,
    /// Analysis commands
    analyses: Vec<SpiceAnalysis>,
    /// Options
    options: SpiceOptions,
}

/// SPICE model definition.
#[derive(Debug, Clone)]
pub struct SpiceModel {
    /// Model name
    pub name: String,
    /// Model type (e.g., "NPN", "NMOS", "D")
    pub model_type: String,
    /// Model parameters
    pub parameters: HashMap<String, String>,
}

/// SPICE subcircuit definition.
#[derive(Debug, Clone)]
pub struct SpiceSubcircuit {
    /// Subcircuit name
    pub name: String,
    /// Port names
    pub ports: Vec<String>,
    /// Internal netlist content
    pub content: String,
}

/// SPICE analysis type.
#[derive(Debug, Clone)]
pub enum SpiceAnalysis {
    /// DC operating point
    Op,
    /// DC sweep
    Dc {
        source: String,
        start: f64,
        stop: f64,
        step: f64,
    },
    /// AC analysis
    Ac {
        variation: AcVariation,
        points: u32,
        start_freq: f64,
        stop_freq: f64,
    },
    /// Transient analysis
    Tran {
        step: f64,
        stop: f64,
        start: Option<f64>,
    },
    /// Custom analysis command
    Custom(String),
}

/// AC variation type.
#[derive(Debug, Clone, Copy)]
pub enum AcVariation {
    /// Decade
    Dec,
    /// Octave
    Oct,
    /// Linear
    Lin,
}

/// SPICE options.
#[derive(Debug, Clone, Default)]
pub struct SpiceOptions {
    /// Include .end directive
    pub include_end: bool,
    /// Include comments
    pub include_comments: bool,
    /// Node name style
    pub node_style: NodeStyle,
}

/// Node naming style.
#[derive(Debug, Clone, Copy, Default)]
pub enum NodeStyle {
    /// Numeric nodes (0, 1, 2, ...)
    #[default]
    Numeric,
    /// Named nodes (GND, VCC, NET1, ...)
    Named,
}

impl SpiceNetlistGenerator {
    /// Create a new SPICE netlist generator.
    pub fn new(title: impl Into<String>) -> Self {
        Self {
            title: title.into(),
            models: Vec::new(),
            subcircuits: Vec::new(),
            analyses: Vec::new(),
            options: SpiceOptions {
                include_end: true,
                include_comments: true,
                node_style: NodeStyle::Named,
            },
        }
    }

    /// Add a model definition.
    pub fn add_model(&mut self, model: SpiceModel) -> &mut Self {
        self.models.push(model);
        self
    }

    /// Add a subcircuit definition.
    pub fn add_subcircuit(&mut self, subcircuit: SpiceSubcircuit) -> &mut Self {
        self.subcircuits.push(subcircuit);
        self
    }

    /// Add an analysis command.
    pub fn add_analysis(&mut self, analysis: SpiceAnalysis) -> &mut Self {
        self.analyses.push(analysis);
        self
    }

    /// Set options.
    pub fn with_options(mut self, options: SpiceOptions) -> Self {
        self.options = options;
        self
    }

    /// Generate SPICE netlist from a schematic sheet.
    pub fn generate(&self, sheet: &SchematicSheet) -> String {
        let mut output = String::new();

        // Title line (first line is always the title in SPICE)
        writeln!(output, "* {}", self.title).unwrap();
        writeln!(output).unwrap();

        // Comments
        if self.options.include_comments {
            writeln!(output, "* Generated by HardwareTool").unwrap();
            writeln!(output, "* Schematic: {}", sheet.name).unwrap();
            writeln!(output).unwrap();
        }

        // Build net map from wires and labels
        let net_map = self.build_net_map(sheet);

        // Models
        if !self.models.is_empty() {
            writeln!(output, "* Models").unwrap();
            for model in &self.models {
                self.write_model(&mut output, model);
            }
            writeln!(output).unwrap();
        }

        // Subcircuits
        for subcircuit in &self.subcircuits {
            self.write_subcircuit(&mut output, subcircuit);
            writeln!(output).unwrap();
        }

        // Components
        if self.options.include_comments {
            writeln!(output, "* Components").unwrap();
        }
        for symbol in &sheet.symbols {
            self.write_component(&mut output, symbol, &net_map);
        }
        writeln!(output).unwrap();

        // Analysis commands
        if !self.analyses.is_empty() {
            if self.options.include_comments {
                writeln!(output, "* Analysis").unwrap();
            }
            for analysis in &self.analyses {
                self.write_analysis(&mut output, analysis);
            }
            writeln!(output).unwrap();
        }

        // End directive
        if self.options.include_end {
            writeln!(output, ".end").unwrap();
        }

        output
    }

    /// Build a map of component pins to net names.
    fn build_net_map(&self, sheet: &SchematicSheet) -> HashMap<String, String> {
        let mut net_map = HashMap::new();

        // Add labeled nets
        for label in &sheet.labels {
            let key = format!("{}_{}", label.position.x as i32, label.position.y as i32);
            net_map.insert(key, label.name.clone());
        }

        // Add power symbols
        for power in &sheet.power_symbols {
            let key = format!("{}_{}", power.position.x as i32, power.position.y as i32);
            let net_name = match power.net_name.to_uppercase().as_str() {
                "GND" | "VSS" | "GROUND" => "0".to_string(),
                name => name.to_string(),
            };
            net_map.insert(key, net_name);
        }

        net_map
    }

    /// Write a model definition.
    fn write_model(&self, output: &mut String, model: &SpiceModel) {
        write!(output, ".model {} {}", model.name, model.model_type).unwrap();
        if !model.parameters.is_empty() {
            write!(output, "(").unwrap();
            let params: Vec<_> = model.parameters.iter()
                .map(|(k, v)| format!("{}={}", k, v))
                .collect();
            write!(output, "{}", params.join(" ")).unwrap();
            write!(output, ")").unwrap();
        }
        writeln!(output).unwrap();
    }

    /// Write a subcircuit definition.
    fn write_subcircuit(&self, output: &mut String, subcircuit: &SpiceSubcircuit) {
        writeln!(output, ".subckt {} {}", subcircuit.name, subcircuit.ports.join(" ")).unwrap();
        for line in subcircuit.content.lines() {
            writeln!(output, "  {}", line).unwrap();
        }
        writeln!(output, ".ends {}", subcircuit.name).unwrap();
    }

    /// Write a component instance.
    fn write_component(&self, output: &mut String, symbol: &PlacedSymbol, net_map: &HashMap<String, String>) {
        let ref_prefix = symbol.reference.chars().next().unwrap_or('X');
        
        // Determine component type and format
        match ref_prefix {
            'R' => {
                // Resistor: R<name> <n+> <n-> <value>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, symbol.value).unwrap();
            }
            'C' => {
                // Capacitor: C<name> <n+> <n-> <value>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, symbol.value).unwrap();
            }
            'L' => {
                // Inductor: L<name> <n+> <n-> <value>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, symbol.value).unwrap();
            }
            'D' => {
                // Diode: D<name> <n+> <n-> <model>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                let model = if symbol.value.is_empty() { "D" } else { &symbol.value };
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, model).unwrap();
            }
            'Q' => {
                // BJT: Q<name> <nc> <nb> <ne> <model>
                let nodes = self.get_three_terminal_nodes(symbol, net_map);
                let model = if symbol.value.is_empty() { "NPN" } else { &symbol.value };
                writeln!(output, "{} {} {} {} {}", symbol.reference, nodes.0, nodes.1, nodes.2, model).unwrap();
            }
            'M' => {
                // MOSFET: M<name> <nd> <ng> <ns> <nb> <model>
                let nodes = self.get_four_terminal_nodes(symbol, net_map);
                let model = if symbol.value.is_empty() { "NMOS" } else { &symbol.value };
                writeln!(output, "{} {} {} {} {} {}", symbol.reference, nodes.0, nodes.1, nodes.2, nodes.3, model).unwrap();
            }
            'V' => {
                // Voltage source: V<name> <n+> <n-> <value>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, symbol.value).unwrap();
            }
            'I' => {
                // Current source: I<name> <n+> <n-> <value>
                let nodes = self.get_two_terminal_nodes(symbol, net_map);
                writeln!(output, "{} {} {} {}", symbol.reference, nodes.0, nodes.1, symbol.value).unwrap();
            }
            'X' | 'U' => {
                // Subcircuit instance: X<name> <nodes...> <subckt>
                let nodes = self.get_symbol_nodes(symbol, net_map);
                let subckt = &symbol.value;
                writeln!(output, "X{} {} {}", symbol.reference, nodes.join(" "), subckt).unwrap();
            }
            _ => {
                // Unknown component - add as comment
                writeln!(output, "* Unknown: {} {} {}", symbol.reference, symbol.value, symbol.symbol_name).unwrap();
            }
        }
    }

    /// Get nodes for a two-terminal component.
    fn get_two_terminal_nodes(&self, symbol: &PlacedSymbol, net_map: &HashMap<String, String>) -> (String, String) {
        let pins = &symbol.pins;
        let node1 = if pins.len() > 0 {
            self.get_node_name(&pins[0].position, net_map)
        } else {
            "N001".to_string()
        };
        let node2 = if pins.len() > 1 {
            self.get_node_name(&pins[1].position, net_map)
        } else {
            "N002".to_string()
        };
        (node1, node2)
    }

    /// Get nodes for a three-terminal component.
    fn get_three_terminal_nodes(&self, symbol: &PlacedSymbol, net_map: &HashMap<String, String>) -> (String, String, String) {
        let pins = &symbol.pins;
        let node1 = if pins.len() > 0 { self.get_node_name(&pins[0].position, net_map) } else { "N001".to_string() };
        let node2 = if pins.len() > 1 { self.get_node_name(&pins[1].position, net_map) } else { "N002".to_string() };
        let node3 = if pins.len() > 2 { self.get_node_name(&pins[2].position, net_map) } else { "N003".to_string() };
        (node1, node2, node3)
    }

    /// Get nodes for a four-terminal component.
    fn get_four_terminal_nodes(&self, symbol: &PlacedSymbol, net_map: &HashMap<String, String>) -> (String, String, String, String) {
        let pins = &symbol.pins;
        let node1 = if pins.len() > 0 { self.get_node_name(&pins[0].position, net_map) } else { "N001".to_string() };
        let node2 = if pins.len() > 1 { self.get_node_name(&pins[1].position, net_map) } else { "N002".to_string() };
        let node3 = if pins.len() > 2 { self.get_node_name(&pins[2].position, net_map) } else { "N003".to_string() };
        let node4 = if pins.len() > 3 { self.get_node_name(&pins[3].position, net_map) } else { "N004".to_string() };
        (node1, node2, node3, node4)
    }

    /// Get all nodes for a symbol.
    fn get_symbol_nodes(&self, symbol: &PlacedSymbol, net_map: &HashMap<String, String>) -> Vec<String> {
        symbol.pins.iter()
            .map(|pin| self.get_node_name(&pin.position, net_map))
            .collect()
    }

    /// Get node name from position.
    fn get_node_name(&self, position: &crate::geometry::Point2D, net_map: &HashMap<String, String>) -> String {
        let key = format!("{}_{}", position.x as i32, position.y as i32);
        net_map.get(&key).cloned().unwrap_or_else(|| {
            match self.options.node_style {
                NodeStyle::Numeric => format!("{}", position.x as i32 * 1000 + position.y as i32),
                NodeStyle::Named => format!("N{}_{}", position.x as i32, position.y as i32),
            }
        })
    }

    /// Write an analysis command.
    fn write_analysis(&self, output: &mut String, analysis: &SpiceAnalysis) {
        match analysis {
            SpiceAnalysis::Op => {
                writeln!(output, ".op").unwrap();
            }
            SpiceAnalysis::Dc { source, start, stop, step } => {
                writeln!(output, ".dc {} {} {} {}", source, start, stop, step).unwrap();
            }
            SpiceAnalysis::Ac { variation, points, start_freq, stop_freq } => {
                let var = match variation {
                    AcVariation::Dec => "dec",
                    AcVariation::Oct => "oct",
                    AcVariation::Lin => "lin",
                };
                writeln!(output, ".ac {} {} {} {}", var, points, start_freq, stop_freq).unwrap();
            }
            SpiceAnalysis::Tran { step, stop, start } => {
                if let Some(start_time) = start {
                    writeln!(output, ".tran {} {} {}", step, stop, start_time).unwrap();
                } else {
                    writeln!(output, ".tran {} {}", step, stop).unwrap();
                }
            }
            SpiceAnalysis::Custom(cmd) => {
                writeln!(output, "{}", cmd).unwrap();
            }
        }
    }
}

impl SpiceModel {
    /// Create a new model.
    pub fn new(name: impl Into<String>, model_type: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            model_type: model_type.into(),
            parameters: HashMap::new(),
        }
    }

    /// Add a parameter.
    pub fn with_param(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.parameters.insert(key.into(), value.into());
        self
    }
}

impl SpiceSubcircuit {
    /// Create a new subcircuit.
    pub fn new(name: impl Into<String>, ports: Vec<String>, content: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            ports,
            content: content.into(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::schematic::SchematicSheet;

    #[test]
    fn test_spice_generator_empty() {
        let sheet = SchematicSheet::new("Test");
        let generator = SpiceNetlistGenerator::new("Test Circuit");
        let netlist = generator.generate(&sheet);
        
        assert!(netlist.contains("* Test Circuit"));
        assert!(netlist.contains(".end"));
    }

    #[test]
    fn test_spice_generator_with_analysis() {
        let sheet = SchematicSheet::new("Test");
        let mut generator = SpiceNetlistGenerator::new("Test Circuit");
        
        generator.add_analysis(SpiceAnalysis::Op);
        generator.add_analysis(SpiceAnalysis::Tran { step: 1e-6, stop: 1e-3, start: None });
        generator.add_analysis(SpiceAnalysis::Ac { 
            variation: AcVariation::Dec, 
            points: 10, 
            start_freq: 1.0, 
            stop_freq: 1e6 
        });
        
        let netlist = generator.generate(&sheet);
        
        assert!(netlist.contains(".op"));
        assert!(netlist.contains(".tran"));
        assert!(netlist.contains(".ac dec"));
    }

    #[test]
    fn test_spice_model() {
        let model = SpiceModel::new("2N2222", "NPN")
            .with_param("BF", "100")
            .with_param("IS", "1e-14");
        
        assert_eq!(model.name, "2N2222");
        assert_eq!(model.model_type, "NPN");
        assert_eq!(model.parameters.len(), 2);
    }

    #[test]
    fn test_spice_subcircuit() {
        let subckt = SpiceSubcircuit::new(
            "OPAMP",
            vec!["IN+".to_string(), "IN-".to_string(), "OUT".to_string()],
            "E1 OUT 0 IN+ IN- 100000"
        );
        
        assert_eq!(subckt.name, "OPAMP");
        assert_eq!(subckt.ports.len(), 3);
    }

    #[test]
    fn test_spice_generator_with_model() {
        let sheet = SchematicSheet::new("Test");
        let mut generator = SpiceNetlistGenerator::new("Test Circuit");
        
        generator.add_model(SpiceModel::new("1N4148", "D")
            .with_param("IS", "2.52e-9")
            .with_param("N", "1.752"));
        
        let netlist = generator.generate(&sheet);
        
        assert!(netlist.contains(".model 1N4148 D"));
    }

    #[test]
    fn test_dc_sweep_analysis() {
        let sheet = SchematicSheet::new("Test");
        let mut generator = SpiceNetlistGenerator::new("DC Sweep");
        
        generator.add_analysis(SpiceAnalysis::Dc {
            source: "V1".to_string(),
            start: 0.0,
            stop: 5.0,
            step: 0.1,
        });
        
        let netlist = generator.generate(&sheet);
        
        assert!(netlist.contains(".dc V1 0 5 0.1"));
    }
}
